using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;

namespace ConcessionSession
{
    /// <summary>
    /// All functions from here to the draw function are generated by visua studio. I have added items to those
    /// functions as I saw fit. All functions after the draw function are of my own device for this game.
    /// I have also created classes to assis in the programing. There is a character class which deals with
    /// creation and usage of customers, an item class that deals with creating items, an order class used
    /// to make an order, a character class used for the player. I have also included some enumerated types 
    /// for ease of programing. Everything will be further explained in the comments that follow.
    /// </summary>
    /// 

    //The items and coloring enumerated types are global to this space and created to refer to data with ease.
    //Items are the different food items in the game. These are used in conjunction with the item class
    public enum Items
    {
        smallSoda, mediumSoda, largeSoda, smallPopcorn, mediumPopcorn, largePopcorn,
        smallNachos, largeNachos, gummyBears, chocolateBar
    }

    //Colorings are the colors for the player where white denotes no player. More colorings should be
    //added if more players are added. Colorings are used for customer claims
    public enum colorings
    {
        white, red, blue
    }


    //The game class!!
    public class Game1 : Microsoft.Xna.Framework.Game
    {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        //The fonts for the game. Both fonts are the same kind but different sizes
        SpriteFont font;
        SpriteFont fontOver;

        //sounds
        SoundEffect candySound;
        SoundEffect dohSound;
        SoundEffect donesySound;
        SoundEffect jesusSound;
        SoundEffect nachosSound;
        SoundEffect popcornSound;
        SoundEffect recycleSound;
        SoundEffect serveSound;
        SoundEffect sodaSound;
        SoundEffect WoohooSound;
        SoundEffect wrongItemSound;
        SoundEffect supermanSound;
        SoundEffect supermanThankSound;
        SoundEffect feelrightDonkey;
        SoundEffect winDonkey;
        SoundEffect thewordsJackie;
        SoundEffect jackieokay;
        SoundEffect fistArnold;
        SoundEffect hastalavistaArnold;
        SoundEffect ironman;
        SoundEffect turnYouIron;
        SoundEffect badaboom;
        SoundEffect multipassLeeloo;
        SoundEffect winMickey;
        SoundEffect looseMickey;
        SoundEffect watchScarlett;
        SoundEffect goodThingsScarlett;

        Song alice;
        Song soReal;
        Song dare;
        Song entertainer;
        Song stromae;
        Song jiggy;
        Song funky;



        //All texture2d items are pictures used in the game. All rectangle items are rectangles on which the 
        // textures are drawn
        Texture2D backgroundTexture;
        Rectangle backgroundRect;

        Texture2D sodaTableTexture;
        Texture2D sodaTTexture;
        Texture2D sodaTGlowTexture;
        Rectangle sodaTableRect;

        Texture2D popcornTableTexture;
        Texture2D popcornTTexture;
        Texture2D popcornTGlowTexture;
        Rectangle popcornTableRect;

        Texture2D garbageTexture;
        Texture2D garbageNTexture;
        Texture2D garbageGlowTexture;
        Rectangle garbageRect;

        Texture2D nachosTableTexture;
        Texture2D nachosTTexture;
        Texture2D nachosTGlowTexture;
        Rectangle nachosTableRect;

        Texture2D candyTTexture;
        Texture2D candyTGlowTexture;
        Texture2D candyTableTexture;
        Rectangle candyTableRect;

        Texture2D characterTexture;
        Texture2D character2Texture;



        Texture2D arenaBottomTexture;
        Rectangle arenaBottomRect;

        Texture2D arenaTopTexture;
        Rectangle arenaTopRect;

        Rectangle itemRect;

        Rectangle bubbleRect;
        Texture2D bubbleTexture;
        Texture2D bubblePlainTexture;
        Texture2D bubbleRedTexture;
        Texture2D bubbleBlueTexture;
        Texture2D bubbleRightTexture;
        Texture2D bubbleBlueRightTexture;
        Texture2D bubbleRedRightTexture;

        Rectangle roundBubbleRect;
        Texture2D roundBubbleDownTexture;
        Texture2D roundBubbleDownBlueTexture;
        Texture2D roundBubbleDownRedTexture;
        Texture2D roundBubbleDownRightTexture;
        Texture2D roundBubbleDownRightBlueTexture;
        Texture2D roundBubbleDownRightRedTexture;
        Texture2D roundBubbleUpTexture;
        Texture2D roundBubbleUpBlueTexture;
        Texture2D roundBubbleUpRedTexture;
        Texture2D roundBubbleUpRightTexture;
        Texture2D roundBubbleUpRightBlueTexture;
        Texture2D roundBubbleUpRightRedTxture;

        Rectangle bigRectangleRect;
        Texture2D bigRectangleRedTexture;
        Texture2D bigRectangleBlueTexture;
        Texture2D bigRectangleWhiteTexture;
        Texture2D bigRectangleTexture;


        Rectangle customerRect;



        Rectangle orderRect;

        //keep the current and previous state of the gamepad. For a button press both are needed.
        GamePadState previousState1;
        GamePadState pad1;

        GamePadState previousState2;
        GamePadState pad2;

        //used as flags for the presence of customers in each area
        int presentTopLeft = 0;
        int presentTopRight = 0;
        int presentTopCenter = 0;
        int presentLeft = 0;
        int presentBottomLeft = 0;
        int presentRight = 0;
        int presentBottomRight = 0;
        //The state of the game. 0 is playing the game and 1 is the game over state, both states created in
        //the update function
        int state;

        //These are used when it is necessary to remember what the player's previous position was
        int previousX;
        int previousY;

        int previous2x;
        int previous2y;

        //used for the areaCollision function to figure out what the correct y should be for a given x in a
        //slanted surface
        int y1;
        //int rectx;
        //level of play
        int level;
        //time per round
        int time = 120;
        //a counter per iteration of the update function
        int counter = 0;

        int patienceLimit;
        //Declaration of an order maker object
        orderMaker order;
        //a list of items
        List<item> foodTypes = new List<item>();

        //These are meant to be collections of skins facing left or right and then put into a list of those
        //collections to be randomly chosen
        List<Texture2D> homerLeft = new List<Texture2D>();
        List<Texture2D> homerRight = new List<Texture2D>();
        List<Texture2D> supermanLeft = new List<Texture2D>();
        List<Texture2D> supermanRight = new List<Texture2D>();
        List<Texture2D> mrSlaveLeft = new List<Texture2D>();
        List<Texture2D> mrSlaveRight = new List<Texture2D>();
        List<Texture2D> donkeyLeft = new List<Texture2D>();
        List<Texture2D> donkeyRight = new List<Texture2D>();
        List<Texture2D> jackieLeft = new List<Texture2D>();
        List<Texture2D> jackieRight = new List<Texture2D>();
        List<Texture2D> arnoldLeft = new List<Texture2D>();
        List<Texture2D> arnoldRight = new List<Texture2D>();
        List<Texture2D> ironManLeft = new List<Texture2D>();
        List<Texture2D> ironManRight = new List<Texture2D>();
        List<Texture2D> leelooLeft = new List<Texture2D>();
        List<Texture2D> leelooRight = new List<Texture2D>();
        List<Texture2D> mickeyLeft = new List<Texture2D>();
        List<Texture2D> mickeyRight = new List<Texture2D>();
        List<Texture2D> scarlettLeft = new List<Texture2D>();
        List<Texture2D> scarlettRight = new List<Texture2D>();

        List<List<Texture2D>> leftCharacters = new List<List<Texture2D>>();
        List<List<Texture2D>> rightCharacters = new List<List<Texture2D>>();


        //declaration of characters
        character player1;
        character player2;

        //local declaration of the different game areas for items or customer spawning
        protected enum Areas
        {
            floor, candy, soda, popcorn, nachos, garbage, topLeft, topCenter,
            topRight, left, bottomLeft, right, bottomRight
        };

        List<Areas> customersPresent = new List<Areas>();

        //array of areas for one to be chosen randomly for spawning
        Areas[] customerAreas = new Areas[7] {Areas.topLeft, Areas.topCenter, 
            Areas.topRight, Areas.left, Areas.bottomLeft, Areas.right, Areas.bottomRight};

        //declaration off all the food items
        item chocolate;
        item gummyBears;
        item smallNachos;
        item largeNachos;
        item smallPopcorn;
        item largePopcorn;
        item mediumPopcorn;
        item smallSoda;
        item mediumSoda;
        item largeSoda;

        //customers for all areas
        customer topLeftCust;
        customer topCenterCust;
        customer topRightCust;
        customer leftCust;
        customer bottomLeftCust;
        customer rightCust;
        customer bottomRightCust;

        //current area declaratioin
        Areas currentArea1;
        Areas currentArea2;

        //Generates random numbers for the game inside the game class
        Random randomNum = new Random();
        int numberOfCustomers;
        int songNum;
        int songPlaying;




        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);


            //Graphics background size
            this.graphics.PreferredBackBufferWidth = 1280;
            this.graphics.PreferredBackBufferHeight = 720;


            Content.RootDirectory = "Content";
        }

        /// <summary>
        /// Allows the game to perform any initialization it needs to before starting to run.
        /// This is where it can query for any required services and load any non-graphic
        /// related content.  Calling base.Initialize will enumerate through any components
        /// and initialize them as well.
        /// </summary>
        protected override void Initialize()
        {
            //initialization of all rectangles
            backgroundRect = new Rectangle(0, 0, 1280, 720);
            sodaTableRect = new Rectangle(259, 285, 167, 110); //295
            popcornTableRect = new Rectangle(853, 296, 167, 100); //853
            garbageRect = new Rectangle(595, 320, 83, 74); //625
            nachosTableRect = new Rectangle(556, 465, 167, 100); //586
            candyTableRect = new Rectangle(556, 180, 167, 100); //200
            arenaTopRect = new Rectangle(0, 20, 1280, 720);
            arenaBottomRect = new Rectangle(0, 20, 1280, 720);
            itemRect = new Rectangle(0, 0, 70, 80);
            orderRect = new Rectangle(80, 15, 60, 75);
            bubbleRect = new Rectangle(0, 0, 300, 100);
            roundBubbleRect = new Rectangle(0, 0, 200, 200);
            customerRect = new Rectangle(260, 10, 105, 140);
            bigRectangleRect = new Rectangle(40, 10, 1200, 700);

            //instantiation of players
            player1 = new character(0, 0, 0, 0, 0, new Rectangle(529, 306, 76, 116));
            player2 = new character(0, 0, 0, 0, 0, new Rectangle(689, 306, 76, 116));

            //The state of gamepad 1. Add new gamepads for more players
            pad1 = GamePad.GetState(PlayerIndex.One);
            pad2 = GamePad.GetState(PlayerIndex.Two);

            //initialization of the level
            level = 5;

            //game starts at state 0 (reguar gameplay)
            state = 0;
            patienceLimit = 10;
            songPlaying = 0;







            base.Initialize();
        }

        /// <summary>
        /// LoadContent will be called once per game and is the place to load
        /// all of your content.
        /// </summary>
        protected override void LoadContent()
        {
            // Create a new SpriteBatch, which can be used to draw textures.
            spriteBatch = new SpriteBatch(GraphicsDevice);

            //Load Textures
            backgroundTexture = Content.Load<Texture2D>("background");

            sodaTTexture = Content.Load<Texture2D>("sodaTable");
            sodaTGlowTexture = Content.Load<Texture2D>("sodaTableGlow");
            sodaTableTexture = sodaTTexture;

            popcornTTexture = Content.Load<Texture2D>("popcornTable");
            popcornTGlowTexture = Content.Load<Texture2D>("popcornTableGlow");
            popcornTableTexture = popcornTTexture;

            garbageNTexture = Content.Load<Texture2D>("garbage");
            garbageGlowTexture = Content.Load<Texture2D>("garbageGlow");
            garbageTexture = garbageNTexture;


            nachosTTexture = Content.Load<Texture2D>("nachosTable");
            nachosTGlowTexture = Content.Load<Texture2D>("nachosTableGlow");
            nachosTableTexture = nachosTTexture;

            candyTTexture = Content.Load<Texture2D>("candyTable");
            candyTGlowTexture = Content.Load<Texture2D>("candyTableGlow");
            candyTableTexture = candyTTexture;

            arenaBottomTexture = Content.Load<Texture2D>("arenaBottom");
            arenaTopTexture = Content.Load<Texture2D>("arenaTop");

            characterTexture = Content.Load<Texture2D>("character");
            character2Texture = Content.Load<Texture2D>("character2");

            bubblePlainTexture = Content.Load<Texture2D>("bubble");
            bubbleTexture = bubblePlainTexture;
            bubbleRedTexture = Content.Load<Texture2D>("bubbleRed");
            bubbleBlueTexture = Content.Load<Texture2D>("bubbleBlue");
            bubbleRightTexture = Content.Load<Texture2D>("bubbleRight");
            bubbleBlueRightTexture = Content.Load<Texture2D>("bubbleBlueRight");
            bubbleRedRightTexture = Content.Load<Texture2D>("bubbleRedRight");



            //instantiate each food item, loads its skin and add it to the list of foods
            foodTypes.Add(chocolate = new item(Items.chocolateBar, Content.Load<Texture2D>("chocolate")));
            foodTypes.Add(gummyBears = new item(Items.gummyBears, Content.Load<Texture2D>("gummyBears")));
            foodTypes.Add(smallNachos = new item(Items.smallNachos, Content.Load<Texture2D>("nachosSmall")));
            foodTypes.Add(largeNachos = new item(Items.largeNachos, Content.Load<Texture2D>("nachosLarge")));
            foodTypes.Add(smallPopcorn = new item(Items.smallPopcorn, Content.Load<Texture2D>("popcornSmall")));
            foodTypes.Add(mediumPopcorn = new item(Items.mediumPopcorn, Content.Load<Texture2D>("popcornMedium")));
            foodTypes.Add(largePopcorn = new item(Items.largePopcorn, Content.Load<Texture2D>("popcornLarge")));
            foodTypes.Add(smallSoda = new item(Items.smallSoda, Content.Load<Texture2D>("sodaSmall")));
            foodTypes.Add(mediumSoda = new item(Items.mediumSoda, Content.Load<Texture2D>("sodaMedium")));
            foodTypes.Add(largeSoda = new item(Items.largeSoda, Content.Load<Texture2D>("sodaLarge")));

            bigRectangleRedTexture = Content.Load<Texture2D>("bigRectangleRed");
            bigRectangleBlueTexture = Content.Load<Texture2D>("bigRectangleBlue");
            bigRectangleWhiteTexture = Content.Load<Texture2D>("bigRectangleWhite");


            //instantiate an order object taking into account the level and available food types
            order = new orderMaker(level, foodTypes);



            roundBubbleDownTexture = Content.Load<Texture2D>("roundBubbleDown");
            roundBubbleDownBlueTexture = Content.Load<Texture2D>("roundBubbleDownBlue");
            roundBubbleDownRedTexture = Content.Load<Texture2D>("roundBubbleDownRed");
            roundBubbleDownRightTexture = Content.Load<Texture2D>("roundBubbleDownRight");
            roundBubbleDownRightBlueTexture = Content.Load<Texture2D>("roundBubbleDownRightBlue");
            roundBubbleDownRightRedTexture = Content.Load<Texture2D>("roundBubbleDownRightRed");
            roundBubbleUpTexture = Content.Load<Texture2D>("roundBubbleUp");
            roundBubbleUpBlueTexture = Content.Load<Texture2D>("roundBubbleUpBlue");
            roundBubbleUpRedTexture = Content.Load<Texture2D>("roundBubbleUpRed");
            roundBubbleUpRightTexture = Content.Load<Texture2D>("roundBubbleUpRight");
            roundBubbleUpRightBlueTexture = Content.Load<Texture2D>("roundBubbleUpRightBlue");
            roundBubbleUpRightRedTxture = Content.Load<Texture2D>("roundBubbleUpRightRed");


            //these are collections of skins used for right and left sides of the field.
            //They are then used in a customer object.
            supermanLeft.Add(Content.Load<Texture2D>("superman"));
            supermanLeft.Add(Content.Load<Texture2D>("supermanBlue"));
            supermanLeft.Add(Content.Load<Texture2D>("supermanRed"));

            supermanRight.Add(Content.Load<Texture2D>("supermanRight"));
            supermanRight.Add(Content.Load<Texture2D>("supermanBlueRight"));
            supermanRight.Add(Content.Load<Texture2D>("supermanRedRight"));
            leftCharacters.Add(supermanLeft);
            rightCharacters.Add(supermanRight);


            homerLeft.Add(Content.Load<Texture2D>("homer"));
            homerLeft.Add(Content.Load<Texture2D>("homerBlue"));
            homerLeft.Add(Content.Load<Texture2D>("homerRed"));

            homerRight.Add(Content.Load<Texture2D>("homerRight"));
            homerRight.Add(Content.Load<Texture2D>("homerBlueRight"));
            homerRight.Add(Content.Load<Texture2D>("homerRedRight"));
            leftCharacters.Add(homerLeft);
            rightCharacters.Add(homerRight);

            mrSlaveLeft.Add(Content.Load<Texture2D>("mrSlave"));
            mrSlaveLeft.Add(Content.Load<Texture2D>("mrSlaveBlue"));
            mrSlaveLeft.Add(Content.Load<Texture2D>("mrSlaveRed"));

            mrSlaveRight.Add(Content.Load<Texture2D>("mrSlaveRight"));
            mrSlaveRight.Add(Content.Load<Texture2D>("mrSlaveBlueRight"));
            mrSlaveRight.Add(Content.Load<Texture2D>("mrSlaveRedRight"));
            leftCharacters.Add(mrSlaveLeft);
            rightCharacters.Add(mrSlaveRight);

            donkeyLeft.Add(Content.Load<Texture2D>("donkey"));
            donkeyLeft.Add(Content.Load<Texture2D>("donkeyBlue"));
            donkeyLeft.Add(Content.Load<Texture2D>("donkeyRed"));

            donkeyRight.Add(Content.Load<Texture2D>("donkeyRight"));
            donkeyRight.Add(Content.Load<Texture2D>("donkeyBlueRight"));
            donkeyRight.Add(Content.Load<Texture2D>("donkeyRedRight"));
            leftCharacters.Add(donkeyLeft);
            rightCharacters.Add(donkeyRight);

            jackieLeft.Add(Content.Load<Texture2D>("jackie"));
            jackieLeft.Add(Content.Load<Texture2D>("jackieBlue"));
            jackieLeft.Add(Content.Load<Texture2D>("jackieRed"));

            jackieRight.Add(Content.Load<Texture2D>("jackieRight"));
            jackieRight.Add(Content.Load<Texture2D>("jackieBlueRight"));
            jackieRight.Add(Content.Load<Texture2D>("jackieRedRight"));
            leftCharacters.Add(jackieLeft);
            rightCharacters.Add(jackieRight);

            arnoldLeft.Add(Content.Load<Texture2D>("arnold"));
            arnoldLeft.Add(Content.Load<Texture2D>("arnoldBlue"));
            arnoldLeft.Add(Content.Load<Texture2D>("arnoldRed"));

            arnoldRight.Add(Content.Load<Texture2D>("arnoldRight"));
            arnoldRight.Add(Content.Load<Texture2D>("arnoldBlueRight"));
            arnoldRight.Add(Content.Load<Texture2D>("arnoldRedRight"));
            leftCharacters.Add(arnoldLeft);
            rightCharacters.Add(arnoldRight);

            ironManLeft.Add(Content.Load<Texture2D>("ironMan"));
            ironManLeft.Add(Content.Load<Texture2D>("ironManBlue"));
            ironManLeft.Add(Content.Load<Texture2D>("ironManRed"));

            ironManRight.Add(Content.Load<Texture2D>("ironManRight"));
            ironManRight.Add(Content.Load<Texture2D>("ironManBlueRight"));
            ironManRight.Add(Content.Load<Texture2D>("ironManRedRight"));
            leftCharacters.Add(ironManLeft);
            rightCharacters.Add(ironManRight);

            leelooLeft.Add(Content.Load<Texture2D>("leeloo"));
            leelooLeft.Add(Content.Load<Texture2D>("leelooBlue"));
            leelooLeft.Add(Content.Load<Texture2D>("leelooRed"));

            leelooRight.Add(Content.Load<Texture2D>("leelooRight"));
            leelooRight.Add(Content.Load<Texture2D>("leelooBlueRight"));
            leelooRight.Add(Content.Load<Texture2D>("leelooRedRight"));
            leftCharacters.Add(leelooLeft);
            rightCharacters.Add(leelooRight);

            mickeyLeft.Add(Content.Load<Texture2D>("mickey"));
            mickeyLeft.Add(Content.Load<Texture2D>("mickeyBlue"));
            mickeyLeft.Add(Content.Load<Texture2D>("mickeyRed"));

            mickeyRight.Add(Content.Load<Texture2D>("mickeyRight"));
            mickeyRight.Add(Content.Load<Texture2D>("mickeyBlueRight"));
            mickeyRight.Add(Content.Load<Texture2D>("mickeyRedRight"));
            leftCharacters.Add(mickeyLeft);
            rightCharacters.Add(mickeyRight);

            scarlettLeft.Add(Content.Load<Texture2D>("Scarlett"));
            scarlettLeft.Add(Content.Load<Texture2D>("ScarlettBlue"));
            scarlettLeft.Add(Content.Load<Texture2D>("ScarlettRed"));

            scarlettRight.Add(Content.Load<Texture2D>("ScarlettRight"));
            scarlettRight.Add(Content.Load<Texture2D>("ScarlettBlueRight"));
            scarlettRight.Add(Content.Load<Texture2D>("ScarlettRedRight"));
            leftCharacters.Add(scarlettLeft);
            rightCharacters.Add(scarlettRight);

            candySound = Content.Load<SoundEffect>("candy");
            dohSound = Content.Load<SoundEffect>("doh");
            donesySound = Content.Load<SoundEffect>("donesy");
            jesusSound = Content.Load<SoundEffect>("jesus");
            nachosSound = Content.Load<SoundEffect>("nachos");
            popcornSound = Content.Load<SoundEffect>("popcorn");
            recycleSound = Content.Load<SoundEffect>("recycle");
            serveSound = Content.Load<SoundEffect>("cashRegister");
            sodaSound = Content.Load<SoundEffect>("soda");
            WoohooSound = Content.Load<SoundEffect>("Woohoo");
            wrongItemSound = Content.Load<SoundEffect>("wrong item");
            supermanSound = Content.Load<SoundEffect>("supermanBored");
            supermanThankSound = Content.Load<SoundEffect>("upAway");
            winDonkey = Content.Load<SoundEffect>("winDonkey");
            feelrightDonkey = Content.Load<SoundEffect>("feelrightDonkey");
            jackieokay = Content.Load<SoundEffect>("jackieokay");
            thewordsJackie = Content.Load<SoundEffect>("thewordsJackie");
            fistArnold = Content.Load<SoundEffect>("hastalavistaArnold");
            hastalavistaArnold = Content.Load<SoundEffect>("ilbeback");
            ironman = Content.Load<SoundEffect>("IAmIronMan");
            turnYouIron = Content.Load<SoundEffect>("run");
            multipassLeeloo = Content.Load<SoundEffect>("multipassLeeloo");
            badaboom = Content.Load<SoundEffect>("badaboom");
            looseMickey = Content.Load<SoundEffect>("looseMickey");
            winMickey = Content.Load<SoundEffect>("winMickey");
            watchScarlett = Content.Load<SoundEffect>("watchScarlett");
            goodThingsScarlett = Content.Load<SoundEffect>("goodThingsScarlett");

            alice = Content.Load<Song>("alice");
            soReal = Content.Load<Song>("soReal");
            dare = Content.Load<Song>("dare");
            jiggy = Content.Load<Song>("Will Smith - Getting Jiggy With It");
            funky = Content.Load<Song>("Wild Cherry - Play That Funky Music White Boy");
            stromae = Content.Load<Song>("Stromae - Alors On Dance");
            entertainer = Content.Load<Song>("Scott_Joplin_-_The_entertainer");

            MediaPlayer.Volume = .3f;
            SoundEffect.MasterVolume = 1.0f;






            //instantiate both fonts using the font files included wiht this project
            font = Content.Load<SpriteFont>("SpriteFont1");
            fontOver = Content.Load<SpriteFont>("SpriteFont2");

        }

        /// <summary>
        /// UnloadContent will be called once per game and is the place to unload
        /// all content.
        /// </summary>
        protected override void UnloadContent()
        {
            // TODO: Unload any non ContentManager content here
        }

        /// <summary>
        /// Allows the game to run logic such as updating the world,
        /// checking for collisions, gathering input, and playing audio.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Update(GameTime gameTime)
        {



            previousState1 = pad1;
            previousState2 = pad2;
            pad1 = GamePad.GetState(PlayerIndex.One);
            pad2 = GamePad.GetState(PlayerIndex.Two);
            // Allows the game to exit
            if (pad1.Buttons.Back == ButtonState.Pressed)
                this.Exit();

            //updates occuring at state 0 (game play)
            if (state == 0)
            {


                if (songPlaying == 0)
                {
                    songNum = randomNum.Next(1, 8);
                    if (songNum == 1)
                        MediaPlayer.Play(alice);

                    else if (songNum == 2)
                        MediaPlayer.Play(dare);

                    else if (songNum == 3)
                        MediaPlayer.Play(soReal);
                    else if (songNum == 4)
                        MediaPlayer.Play(funky);
                    else if (songNum == 5)
                        MediaPlayer.Play(entertainer);
                    else if (songNum == 6)
                        MediaPlayer.Play(stromae);
                    else if (songNum == 7)
                        MediaPlayer.Play(jiggy);
                    songPlaying = 1;
                }


                //adds 1 to the counter until the counter equals 61 at which point the counter becomes 1 again
                //the counter basically counts to one second at which point one is subtracted from game time
                //and the patience of the customer. Notice how homer leaves at -1. This allows the player to
                //barely save an order at the last second
                counter = counter + 1;
                if (counter == 61) counter = 1;

                if (counter == 60)
                {
                    time = time - 1;

                }





                if (time == 0)
                {
                    state = 1;
                }


                //record the player's position before the new position calculations occur
                previousX = player1.position.X;
                previousY = player1.position.Y;

                previous2x = player2.position.X;
                previous2y = player2.position.Y;

                //calculate new player position based on the left thumbstick movement
                player1.position.X = player1.position.X + ((int)(6 * pad1.ThumbSticks.Left.X));
                player1.position.Y = player1.position.Y - ((int)(6 * pad1.ThumbSticks.Left.Y));



                player2.position.X = player2.position.X + ((int)(6 * pad2.ThumbSticks.Left.X));
                player2.position.Y = player2.position.Y - ((int)(6 * pad2.ThumbSticks.Left.Y));

                //find out which area is enabled by a player and save it to current area
                currentArea1 = AreaEnabled(player1);
                currentArea2 = AreaEnabled(player2);

                customerManager();
                customerSpawn();

                //this function looks at the buttons pressed and adds items to the player or subtracts
                //them depending on the area
                itemManager(player1, currentArea1, previousState1, pad1);
                itemManager(player2, currentArea2, previousState2, pad2);

                //Detects if there has been a collision with walls and keeps player from moving through them
                AreaCollision(player1, previousX, previousY);
                AreaCollision(player2, previous2x, previous2y);
            }

            //this is the game over state. It does nothing until the player presses a at which point it goes
            //back to state 0
            if (state == 1)
            {
                songPlaying = 0;
                MediaPlayer.Stop();
                if (pad1.Buttons.Start == ButtonState.Pressed)
                {
                    state = 0;
                    time = 120;
                    counter = 0;
                    player1 = new character(0, 0, 0, 0, 0, new Rectangle(529, 306, 76, 116));
                    player2 = new character(0, 0, 0, 0, 0, new Rectangle(689, 306, 76, 116));
                    customersPresent = new List<Areas>();

                }

            }

            base.Update(gameTime);
        }

        /// <summary>
        /// This is called when the game should draw itself.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Draw(GameTime gameTime)
        {
            GraphicsDevice.Clear(Color.CornflowerBlue);




            spriteBatch.Begin();

            //this function draws items on screen in the correct order
            drawBatch();


            spriteBatch.End();

            base.Draw(gameTime);
        }

        //this is the function that is called when drawing items on to the screen in the correct order
        protected void drawBatch()
        {
            //positions for the different lines of words drawn to the screen
            Vector2 v1 = new Vector2(240, 600);
            Vector2 v2 = new Vector2(520, 580);
            Vector2 v3 = new Vector2(580, 620);
            Vector2 v4 = new Vector2(850, 600);

            Vector2 v6 = new Vector2(270, 100);
            Vector2 v7 = new Vector2(450, 650);
            Vector2 vStat1 = new Vector2(150, 200);
            Vector2 vStat2 = new Vector2(800, 200);
            Vector2 vItemsServed1 = new Vector2(150, 240);
            Vector2 vItemsServed2 = new Vector2(800, 240);
            Vector2 vOrdersFinished1 = new Vector2(150, 280);
            Vector2 vOrdersFinished2 = new Vector2(800, 280);
            Vector2 vSaves1 = new Vector2(150, 320);
            Vector2 vSaves2 = new Vector2(800, 320);
            Vector2 vBonusPoints1 = new Vector2(150, 360);
            Vector2 vBonusPoints2 = new Vector2(800, 360);
            Vector2 vScore1 = new Vector2(150, 400);
            Vector2 vScore2 = new Vector2(800, 400);
            Vector2 vBottomLeft = new Vector2(0, 500);
            Vector2 vBottomRight = new Vector2(1255, 500);
            Vector2 vLeft = new Vector2(0, 330);
            Vector2 vRight = new Vector2(1255, 330);
            Vector2 vTopCenter = new Vector2(738, 50);
            Vector2 vTopLeft = new Vector2(350, 50);
            Vector2 vTopRight = new Vector2(900, 50);
            Vector2 vTest = new Vector2(0, 0);

            string whoWon;
            Color winner;

            //Draws textures to screen
            spriteBatch.Draw(backgroundTexture, backgroundRect, Color.White);

            //this draws the character and the patience count when its running out
            for (int i = 0; i < customersPresent.Count; i++)
            {


                if (customersPresent[i] == Areas.bottomLeft)
                {

                    customerRect.X = 26;
                    customerRect.Y = 440;

                    spriteBatch.Draw(bottomLeftCust.CurrentTexture, customerRect, Color.White);

                    if (counter == 60) bottomLeftCust.Patience = bottomLeftCust.Patience - 1;
                    if (bottomLeftCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentBottomLeft = 0;
                    }

                    else if (bottomLeftCust.Patience <= patienceLimit)
                    {
                        if (bottomLeftCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(bottomLeftCust);
                        spriteBatch.DrawString(font, bottomLeftCust.Patience.ToString(), vBottomLeft, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.bottomRight)
                {
                    customerRect.X = 1190;
                    customerRect.Y = 440;
                    spriteBatch.Draw(bottomRightCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) bottomRightCust.Patience = bottomRightCust.Patience - 1;
                    if (bottomRightCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentBottomRight = 0;
                    }

                    else if (bottomRightCust.Patience <= patienceLimit)
                    {
                        if (bottomRightCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(bottomRightCust);
                        spriteBatch.DrawString(font, bottomRightCust.Patience.ToString(), vBottomRight, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.left)
                {
                    customerRect.X = 26;
                    customerRect.Y = 280;
                    spriteBatch.Draw(leftCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) leftCust.Patience = leftCust.Patience - 1;
                    if (leftCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentLeft = 0;
                    }

                    else if (leftCust.Patience <= patienceLimit)
                    {
                        if (leftCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(leftCust);
                        spriteBatch.DrawString(font, leftCust.Patience.ToString(), vLeft, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.right)
                {
                    customerRect.X = 1190;
                    customerRect.Y = 280;
                    spriteBatch.Draw(rightCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) rightCust.Patience = rightCust.Patience - 1;
                    if (rightCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentRight = 0;
                    }

                    else if (rightCust.Patience <= patienceLimit)
                    {
                        if (rightCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(rightCust);
                        spriteBatch.DrawString(font, rightCust.Patience.ToString(), vRight, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.topCenter)
                {
                    customerRect.X = 648;
                    customerRect.Y = 10;
                    spriteBatch.Draw(topCenterCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) topCenterCust.Patience = topCenterCust.Patience - 1;
                    if (topCenterCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentTopCenter = 0;
                    }

                    else if (topCenterCust.Patience <= patienceLimit)
                    {
                        if (topCenterCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(topCenterCust);
                        spriteBatch.DrawString(font, topCenterCust.Patience.ToString(), vTopCenter, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.topLeft)
                {
                    customerRect.X = 260;
                    customerRect.Y = 10;
                    spriteBatch.Draw(topLeftCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) topLeftCust.Patience = topLeftCust.Patience - 1;
                    if (topLeftCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentTopLeft = 0;
                    }

                    else if (topLeftCust.Patience <= patienceLimit)
                    {
                        if (topLeftCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(topLeftCust);
                        spriteBatch.DrawString(font, topLeftCust.Patience.ToString(), vTopLeft, Color.Yellow);
                    }
                }
                else if (customersPresent[i] == Areas.topRight)
                {
                    
                    customerRect.X = 930;
                    //customerRect.X = 1190;
                    customerRect.Y = 10;
                    
                    
                    spriteBatch.Draw(topRightCust.CurrentTexture, customerRect, Color.White);
                    if (counter == 60) topRightCust.Patience = topRightCust.Patience - 1;
                    if (topRightCust.Patience == -1)
                    {
                        customersPresent.RemoveAt(i);
                        presentTopRight = 0;
                    }

                    else if (topRightCust.Patience <= patienceLimit)
                    {
                        if (topRightCust.Patience == patienceLimit && counter == 2)
                            timeEndingSounds(topRightCust);
                        spriteBatch.DrawString(font, topRightCust.Patience.ToString(), vTopRight, Color.Yellow);
                    }
                }
            }



            spriteBatch.Draw(arenaTopTexture, arenaTopRect, Color.White);

            //Draws the bubbles and items on the customers that spawn at the top
            for (int i = 0; i < customersPresent.Count; i++)
            {

                if (customersPresent[i] == Areas.topCenter)
                {
                    bubbleRect.X = 380;
                    bubbleRect.Y = 0;
                    orderRect.X = 410;
                    orderRect.Y = 10;
                    if (currentArea1 == Areas.topCenter)
                        spriteBatch.Draw(bubbleRedTexture, bubbleRect, Color.White);
                    else if (currentArea2 == Areas.topCenter)
                        spriteBatch.Draw(bubbleBlueTexture, bubbleRect, Color.White);
                    else
                        spriteBatch.Draw(bubbleTexture, bubbleRect, Color.White);
                    for (int m = 0; m < topCenterCust.Order.Count(); m++)
                    {

                        spriteBatch.Draw(topCenterCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }
                }
                else if (customersPresent[i] == Areas.topLeft)
                {
                    bubbleRect.X = 0;
                    bubbleRect.Y = 0;
                    orderRect.X = 20;
                    orderRect.Y = 15;
                    if (currentArea1 == Areas.topLeft)
                        spriteBatch.Draw(bubbleRedTexture, bubbleRect, Color.White);
                    else if (currentArea2 == Areas.topLeft)
                        spriteBatch.Draw(bubbleBlueTexture, bubbleRect, Color.White);
                    else
                        spriteBatch.Draw(bubbleTexture, bubbleRect, Color.White);
                    for (int m = 0; m < topLeftCust.Order.Count(); m++)
                    {

                        spriteBatch.Draw(topLeftCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }
                }
                else if (customersPresent[i] == Areas.topRight)
                {
                    bubbleRect.X = 980;
                    //bubbleRect.X = 1090;
                    bubbleRect.Y = 0;
                    orderRect.X = 1020;
                    //orderRect.X = 1120;
                    orderRect.Y = 10;
                    if (currentArea1 == Areas.topRight)
                        spriteBatch.Draw(bubbleRedTexture, bubbleRect, Color.White);
                    else if (currentArea2 == Areas.topRight)
                        spriteBatch.Draw(bubbleBlueTexture, bubbleRect, Color.White);
                    else
                        spriteBatch.Draw(bubbleTexture, bubbleRect, Color.White);
                    for (int m = 0; m < topRightCust.Order.Count(); m++)
                    {

                        spriteBatch.Draw(topRightCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }
                }
            }




            //What follows is an interplay of cases in which the player may be found in different areas.
            //in each case the player gets drawn before oter objects in the field. 
            //this will have to change to account for an other player
            //if (player1.position.Y  < 170 && player2.position.Y < 170){


            if (player1.position.Y < 170)
                spriteBatch.Draw(characterTexture, player1.position, Color.White);

            if (player2.position.Y < 170)
                spriteBatch.Draw(character2Texture, player2.position, Color.White);

            if (currentArea1 == Areas.candy || currentArea2 == Areas.candy)
                spriteBatch.Draw(candyTGlowTexture, candyTableRect, Color.White);
            else
                spriteBatch.Draw(candyTTexture, candyTableRect, Color.White);

            if (player1.position.Y < 290 && player1.position.Y >= 170)
                spriteBatch.Draw(characterTexture, player1.position, Color.White);
            if (player2.position.Y < 290 && player2.position.Y >= 170)
                spriteBatch.Draw(character2Texture, player2.position, Color.White);

            if (currentArea1 == Areas.soda || currentArea2 == Areas.soda)
                spriteBatch.Draw(sodaTGlowTexture, sodaTableRect, Color.White);
            else
                spriteBatch.Draw(sodaTTexture, sodaTableRect, Color.White);

            if (currentArea1 == Areas.popcorn || currentArea2 == Areas.popcorn)
                spriteBatch.Draw(popcornTGlowTexture, popcornTableRect, Color.White);
            else
                spriteBatch.Draw(popcornTTexture, popcornTableRect, Color.White);

            if (currentArea1 == Areas.garbage || currentArea2 == Areas.garbage)
                spriteBatch.Draw(garbageGlowTexture, garbageRect, Color.White);
            else
                spriteBatch.Draw(garbageNTexture, garbageRect, Color.White);

            if (player1.position.Y < 455 && player1.position.Y >= 290)
                spriteBatch.Draw(characterTexture, player1.position, Color.White);

            if (player2.position.Y < 455 && player2.position.Y >= 290)
                spriteBatch.Draw(character2Texture, player2.position, Color.White);

            if (currentArea1 == Areas.nachos || currentArea2 == Areas.nachos)
                spriteBatch.Draw(nachosTGlowTexture, nachosTableRect, Color.White);
            else
                spriteBatch.Draw(nachosTTexture, nachosTableRect, Color.White);

            if (player1.position.Y >= 455)
                spriteBatch.Draw(characterTexture, player1.position, Color.White);
            if (player2.position.Y >= 455)
                spriteBatch.Draw(character2Texture, player2.position, Color.White);

            spriteBatch.Draw(arenaBottomTexture, arenaBottomRect, Color.White);

            //This draws the side and bottom bubbles and food items
            for (int i = 0; i < customersPresent.Count; i++)
            {
                if (customersPresent[i] == Areas.left)
                {
                    roundBubbleRect.X = 0;
                    roundBubbleRect.Y = 100;
                    orderRect.X = 30;
                    orderRect.Y = 130;
                    if (currentArea1 == Areas.left)
                        spriteBatch.Draw(roundBubbleDownRedTexture, roundBubbleRect, Color.White);
                    else if (currentArea2 == Areas.left)
                        spriteBatch.Draw(roundBubbleDownBlueTexture, roundBubbleRect, Color.White);
                    else
                        spriteBatch.Draw(roundBubbleDownTexture, roundBubbleRect, Color.White);
                    for (int m = 0; m < leftCust.Order.Count(); m++)
                    {
                        if (m == 2)
                        {
                            orderRect.X = 30;
                            orderRect.Y = orderRect.Y + orderRect.Height;
                        }
                        spriteBatch.Draw(leftCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }
                }
                else if (customersPresent[i] == Areas.right)
                {
                    roundBubbleRect.X = 1090;
                    roundBubbleRect.Y = 100;
                    orderRect.X = 1120;
                    orderRect.Y = 130;
                    if (currentArea1 == Areas.right)
                        spriteBatch.Draw(roundBubbleDownRightRedTexture, roundBubbleRect, Color.White);
                    else if (currentArea2 == Areas.right)
                        spriteBatch.Draw(roundBubbleDownRightBlueTexture, roundBubbleRect, Color.White);
                    else
                        spriteBatch.Draw(roundBubbleDownRightTexture, roundBubbleRect, Color.White);
                    for (int m = 0; m < rightCust.Order.Count(); m++)
                    {
                        if (m == 2)
                        {
                            orderRect.X = 1120;
                            orderRect.Y = orderRect.Y + orderRect.Height;
                        }
                        spriteBatch.Draw(rightCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }

                }
                else if (customersPresent[i] == Areas.bottomLeft)
                {

                    roundBubbleRect.X = 0;
                    roundBubbleRect.Y = 520;
                    orderRect.X = 30;
                    orderRect.Y = 560;
                    if (currentArea1 == Areas.bottomLeft)
                        spriteBatch.Draw(roundBubbleUpRedTexture, roundBubbleRect, Color.White);
                    else if (currentArea2 == Areas.bottomLeft)
                        spriteBatch.Draw(roundBubbleUpBlueTexture, roundBubbleRect, Color.White);
                    else
                        spriteBatch.Draw(roundBubbleUpTexture, roundBubbleRect, Color.White);
                    for (int m = 0; m < bottomLeftCust.Order.Count(); m++)
                    {
                        if (m == 2)
                        {
                            orderRect.X = 30;
                            orderRect.Y = orderRect.Y + orderRect.Height;
                        }
                        spriteBatch.Draw(bottomLeftCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }

                }
                else if (customersPresent[i] == Areas.bottomRight)
                {
                    roundBubbleRect.X = 1090;
                    roundBubbleRect.Y = 520;
                    orderRect.X = 1120;
                    orderRect.Y = 550;
                    if (currentArea1 == Areas.bottomRight)
                        spriteBatch.Draw(roundBubbleUpRightRedTxture, roundBubbleRect, Color.White);
                    else if (currentArea2 == Areas.bottomRight)
                        spriteBatch.Draw(roundBubbleUpRightBlueTexture, roundBubbleRect, Color.White);
                    else
                        spriteBatch.Draw(roundBubbleUpRightTexture, roundBubbleRect, Color.White);
                    for (int m = 0; m < bottomRightCust.Order.Count(); m++)
                    {
                        if (m == 2)
                        {
                            orderRect.X = 1110;
                            orderRect.Y = orderRect.Y + orderRect.Height;
                        }
                        spriteBatch.Draw(bottomRightCust.Order[m].ItemTexture, orderRect, Color.White);
                        orderRect.X = orderRect.X + orderRect.Width - 5;
                    }
                }
            }

            //this draws the items a player is carrying
            if (player1.Carrying.Count() == 1)
            {
                itemRect.X = player1.position.X - 70;
                itemRect.Y = player1.position.Y;
                spriteBatch.Draw(player1.Carrying[0].ItemTexture, itemRect, Color.White);

            }
            else if (player1.Carrying.Count() == 2)
            {
                itemRect.X = player1.position.X - 70;
                itemRect.Y = player1.position.Y;
                spriteBatch.Draw(player1.Carrying[0].ItemTexture, itemRect, Color.White);

                itemRect.X = player1.position.X + player1.position.Width;
                itemRect.Y = player1.position.Y;
                spriteBatch.Draw(player1.Carrying[1].ItemTexture, itemRect, Color.White);
            }


            if (player2.Carrying.Count() == 1)
            {
                itemRect.X = player2.position.X - 70;
                itemRect.Y = player2.position.Y;
                spriteBatch.Draw(player2.Carrying[0].ItemTexture, itemRect, Color.White);

            }
            else if (player2.Carrying.Count() == 2)
            {
                itemRect.X = player2.position.X - 70;
                itemRect.Y = player2.position.Y;
                spriteBatch.Draw(player2.Carrying[0].ItemTexture, itemRect, Color.White);

                itemRect.X = player2.position.X + player2.position.Width;
                itemRect.Y = player2.position.Y;
                spriteBatch.Draw(player2.Carrying[1].ItemTexture, itemRect, Color.White);
            }


            //this draws time and scores
            spriteBatch.DrawString(font, "Score: " + player1.Score.ToString(), v1, Color.DarkRed);
            spriteBatch.DrawString(font, "Time Left:", v2, Color.White);
            spriteBatch.DrawString(font, time.ToString(), v3, Color.White);
            spriteBatch.DrawString(font, "Score: " + player2.Score.ToString(), v4, Color.DarkBlue);


            //draws game over if state is 1
            if (state == 1)
            {

                if (player1.Score > player2.Score)
                {
                    whoWon = "PLAYER ONE WINS!!";
                    bigRectangleTexture = bigRectangleRedTexture;
                    winner = Color.DarkRed;
                }

                else if (player1.Score < player2.Score)
                {
                    whoWon = "PLAYER TWO WINS";
                    bigRectangleTexture = bigRectangleBlueTexture;
                    winner = Color.DarkBlue;
                }
                else
                {
                    whoWon = "THE GAME IS TIED!!";
                    bigRectangleTexture = bigRectangleWhiteTexture;
                    winner = Color.White;
                }
                spriteBatch.Draw(bigRectangleTexture, bigRectangleRect, Color.White);
                spriteBatch.DrawString(fontOver, whoWon, v6, winner);
                spriteBatch.DrawString(font, "Player One Stats:", vStat1, Color.DarkRed);
                spriteBatch.DrawString(font, "Player Two Stats:", vStat2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Items Served: " + player1.ItemsServed, vItemsServed1, Color.DarkRed);
                spriteBatch.DrawString(font, "Items Served: " + player2.ItemsServed, vItemsServed2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Orders Finished: " + player1.OrdersFinished, vOrdersFinished1, Color.DarkRed);
                spriteBatch.DrawString(font, "Orders Finished: " + player2.OrdersFinished, vOrdersFinished2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Customers Saved: " + player1.CustomersSaved, vSaves1, Color.DarkRed);
                spriteBatch.DrawString(font, "Customers Saved: " + player2.CustomersSaved, vSaves2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Bonus Points: " + player1.BonusPoints, vBonusPoints1, Color.DarkRed);
                spriteBatch.DrawString(font, "Bonus Points: " + player2.BonusPoints, vBonusPoints2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Total Score: " + player1.Score, vScore1, Color.DarkRed);
                spriteBatch.DrawString(font, "Total Score: " + player2.Score, vScore2, Color.DarkBlue);
                spriteBatch.DrawString(font, "Press Start to continue", v7, Color.White);

            }

        }

        //this function adds or removes items from the player depending on the area and the player's condition
        //as it is now it also removes items from homer. It will be necessary to modify this function
        //to account for different areas and customers
        private void itemManager(character player, Areas currentArea, GamePadState previousState, GamePadState padNow)
        {
            if (player.Carrying.Count() < 2)
            {
                if (currentArea == Areas.candy)
                {
                    if (padNow.Buttons.X == ButtonState.Released && previousState.Buttons.X == ButtonState.Pressed)
                    {
                        player.Carrying.Add(chocolate);
                        candySound.Play();
                    }
                    else if (padNow.Buttons.A == ButtonState.Released && previousState.Buttons.A == ButtonState.Pressed)
                    {
                        player.Carrying.Add(gummyBears);
                        candySound.Play();
                    }
                }

                else if (currentArea == Areas.nachos)
                {
                    if (padNow.Buttons.X == ButtonState.Released && previousState.Buttons.X == ButtonState.Pressed)
                    {
                        player.Carrying.Add(largeNachos);
                        nachosSound.Play();
                    }
                    else if (padNow.Buttons.A == ButtonState.Released && previousState.Buttons.A == ButtonState.Pressed)
                    {
                        player.Carrying.Add(smallNachos);
                        nachosSound.Play();
                    }
                }

                else if (currentArea == Areas.popcorn)
                {
                    if (padNow.Buttons.X == ButtonState.Released && previousState.Buttons.X == ButtonState.Pressed)
                    {
                        player.Carrying.Add(largePopcorn);
                        popcornSound.Play();
                    }
                    else if (padNow.Buttons.A == ButtonState.Released && previousState.Buttons.A == ButtonState.Pressed)
                    {
                        player.Carrying.Add(mediumPopcorn);
                        popcornSound.Play();
                    }
                    else if (padNow.Buttons.B == ButtonState.Released && previousState.Buttons.B == ButtonState.Pressed)
                    {
                        player.Carrying.Add(smallPopcorn);
                        popcornSound.Play();
                    }
                }

                else if (currentArea == Areas.soda)
                {
                    if (padNow.Buttons.X == ButtonState.Released && previousState.Buttons.X == ButtonState.Pressed)
                    {
                        player.Carrying.Add(largeSoda);
                        sodaSound.Play();
                    }
                    else if (padNow.Buttons.A == ButtonState.Released && previousState.Buttons.A == ButtonState.Pressed)
                    {
                        player.Carrying.Add(mediumSoda);
                        sodaSound.Play();
                    }
                    else if (padNow.Buttons.B == ButtonState.Released && previousState.Buttons.B == ButtonState.Pressed)
                    {
                        player.Carrying.Add(smallSoda);
                        sodaSound.Play();
                    }
                }
            }
            if (currentArea == Areas.garbage)
            {
                if (player.Carrying.Count() == 1 && (padNow.Buttons.LeftShoulder == ButtonState.Released
                    && previousState.Buttons.LeftShoulder == ButtonState.Pressed
                    || padNow.Triggers.Left < .5 && previousState.Triggers.Left > .5)
                    )
                {
                    player.Carrying.RemoveAt(0);
                    recycleSound.Play();
                }
                else if (player.Carrying.Count() == 2)
                {
                    //see ordercomparison function for explanation of why bellow code was commented out
                    if (padNow.Buttons.RightShoulder == ButtonState.Pressed || padNow.Triggers.Right > .5)
                    {
                        //&& previousState.Buttons.RightShoulder == ButtonState.Pressed)
                        player.Carrying.RemoveAt(1);
                        recycleSound.Play();
                    }
                    if (padNow.Buttons.LeftShoulder == ButtonState.Released
                    && previousState.Buttons.LeftShoulder == ButtonState.Pressed
                    || padNow.Triggers.Left < .5 && previousState.Triggers.Left > .5)
                    {

                        player.Carrying.RemoveAt(0);
                        recycleSound.Play();
                    }
                }
            }

           //if the character has no more items in his order give player the bonus and create a new customer
            else if (currentArea == Areas.topLeft)
            {
                if (presentTopLeft == 1)
                {
                    orderComparison(player, topLeftCust, previousState, padNow);
                    if (topLeftCust.Order.Count() == 0)
                    {
                        doneSounds(topLeftCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + topLeftCust.Bonus;
                        if (topLeftCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            topLeftCust.Bonus = topLeftCust.Bonus + 3;
                        }
                        player.Score = player.Score + topLeftCust.Bonus;
                        customersPresent.Remove(Areas.topLeft);
                        presentTopLeft = 0;
                    }
                }
            }
            else if (currentArea == Areas.topCenter)
            {
                if (presentTopCenter == 1)
                {
                    orderComparison(player, topCenterCust, previousState, padNow);
                    if (topCenterCust.Order.Count() == 0)
                    {
                        doneSounds(topCenterCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + topCenterCust.Bonus;
                        if (topCenterCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            topCenterCust.Bonus = topCenterCust.Bonus + 3;
                        }
                        player.Score = player.Score + topCenterCust.Bonus;
                        customersPresent.Remove(Areas.topCenter);
                        presentTopCenter = 0;
                    }
                }
            }
            else if (currentArea == Areas.topRight)
            {
                if (presentTopRight == 1)
                {
                    orderComparison(player, topRightCust, previousState, padNow);
                    if (topRightCust.Order.Count() == 0)
                    {
                        doneSounds(topRightCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + topRightCust.Bonus;
                        if (topRightCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            topRightCust.Bonus = topRightCust.Bonus + 3;
                        }
                        player.Score = player.Score + topRightCust.Bonus;
                        customersPresent.Remove(Areas.topRight);
                        presentTopRight = 0;
                    }
                }
            }
            else if (currentArea == Areas.bottomLeft)
            {
                if (presentBottomLeft == 1)
                {

                    orderComparison(player, bottomLeftCust, previousState, padNow);
                    if (bottomLeftCust.Order.Count() == 0)
                    {
                        doneSounds(bottomLeftCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + bottomLeftCust.Bonus;
                        if (bottomLeftCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            bottomLeftCust.Bonus = bottomLeftCust.Bonus + 3;
                        }
                        player.Score = player.Score + bottomLeftCust.Bonus;
                        customersPresent.Remove(Areas.bottomLeft);
                        presentBottomLeft = 0;
                    }
                }
            }
            else if (currentArea == Areas.bottomRight)
            {
                if (presentBottomRight == 1)
                {
                    orderComparison(player, bottomRightCust, previousState, padNow);
                    if (bottomRightCust.Order.Count() == 0)
                    {
                        doneSounds(bottomRightCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + bottomRightCust.Bonus;
                        if (bottomRightCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            bottomRightCust.Bonus = bottomRightCust.Bonus + 3;
                        }
                        player.Score = player.Score + bottomRightCust.Bonus;
                        customersPresent.Remove(Areas.bottomRight);
                        presentBottomRight = 0;
                    }
                }
            }
            else if (currentArea == Areas.left)
            {
                if (presentLeft == 1)
                {
                    orderComparison(player, leftCust, previousState, padNow);
                    if (leftCust.Order.Count() == 0)
                    {
                        doneSounds(leftCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + leftCust.Bonus;
                        if (leftCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            leftCust.Bonus = leftCust.Bonus + 3;
                        }
                        player.Score = player.Score + leftCust.Bonus;
                        customersPresent.Remove(Areas.left);
                        presentLeft = 0;
                    }
                }
            }
            else if (currentArea == Areas.right)
            {
                if (presentRight == 1)
                {
                    orderComparison(player, rightCust, previousState, padNow);
                    if (rightCust.Order.Count() == 0)
                    {
                        doneSounds(rightCust);
                        player.OrdersFinished = player.OrdersFinished + 1;
                        player.BonusPoints = player.BonusPoints + rightCust.Bonus;
                        if (rightCust.Patience < 5)
                        {
                            player.CustomersSaved = player.CustomersSaved + 1;
                            rightCust.Bonus = rightCust.Bonus + 3;
                        }
                        player.Score = player.Score + rightCust.Bonus;
                        customersPresent.Remove(Areas.right);
                        presentRight = 0;
                    }
                }
            }
        }

        //sounds to be played if an order is completed
        private void doneSounds(customer current)
        {
            if (current.textures == mrSlaveLeft || current.textures == mrSlaveRight)
                donesySound.Play();
            else if (current.textures == homerLeft || current.textures == homerRight)
                WoohooSound.Play();
            else if (current.textures == supermanLeft || current.textures == supermanRight)
                supermanThankSound.Play();
            else if (current.textures == donkeyLeft || current.textures == donkeyRight)
                winDonkey.Play();
            else if (current.textures == jackieLeft || current.textures == jackieRight)
                jackieokay.Play();
            else if (current.textures == arnoldLeft || current.textures == arnoldRight)
                hastalavistaArnold.Play();
            else if (current.textures == ironManLeft || current.textures == ironManRight)
                ironman.Play();
            else if (current.textures == leelooLeft || current.textures == leelooRight)
                multipassLeeloo.Play();
            else if (current.textures == mickeyLeft || current.textures == mickeyRight)
                winMickey.Play();
            else if (current.textures == scarlettLeft || current.textures == scarlettRight)
                goodThingsScarlett.Play();
        }

        //Sounds to be played when there are 10 seconds left
        private void timeEndingSounds(customer current)
        {
            if (current.textures == mrSlaveLeft || current.textures == mrSlaveRight)
                jesusSound.Play();
            else if (current.textures == homerLeft || current.textures == homerRight)
                dohSound.Play();
            else if (current.textures == supermanLeft || current.textures == supermanRight)
                supermanSound.Play();
            else if (current.textures == donkeyLeft || current.textures == donkeyRight)
                feelrightDonkey.Play();
            else if (current.textures == jackieLeft || current.textures == jackieRight)
                thewordsJackie.Play();
            else if (current.textures == arnoldLeft || current.textures == arnoldRight)
                fistArnold.Play();
            else if (current.textures == ironManLeft || current.textures == ironManRight)
                turnYouIron.Play();
            else if (current.textures == leelooLeft || current.textures == leelooRight)
                badaboom.Play();
            else if (current.textures == mickeyLeft || current.textures == mickeyRight)
                looseMickey.Play();
            else if (current.textures == scarlettLeft || current.textures == scarlettRight)
                watchScarlett.Play();
        }

        //decides how many customers will be kept on the screen at a time. At this time its constant
        //but this may change for other models
        private void customerManager()
        {

            Areas newest;
            if (level == 1)
            {
                while (customersPresent.Count() < 2)
                {

                    newest = customerAreas[randomNum.Next(0, 7)];
                    if (!customersPresent.Contains(newest))
                        customersPresent.Add(newest);
                }
            }
            else if (level == 2)
            {
                while (customersPresent.Count() < 3)
                {

                    newest = customerAreas[randomNum.Next(0, 7)];
                    if (!customersPresent.Contains(newest))
                        customersPresent.Add(newest);
                }
            }
            else if (level == 3 || level == 4)
            {

                while (customersPresent.Count() < 3)
                {

                    newest = customerAreas[randomNum.Next(0, 7)];
                    if (!customersPresent.Contains(newest))
                        customersPresent.Add(newest);
                }

            }
            else if (level > 4)
            {
                if (customersPresent.Count() <= 1)
                {
                    numberOfCustomers = randomNum.Next(3, 6);
                    while (customersPresent.Count() < numberOfCustomers)
                    {

                        newest = customerAreas[randomNum.Next(0, 7)];
                        if (!customersPresent.Contains(newest))
                            customersPresent.Add(newest);
                    }
                }

            }
        }

        //this creates new customers if they have not yet been created according to the areas list for next customer
        //to create
        private void customerSpawn()
        {
            for (int i = 0; i < customersPresent.Count(); i++)
            {
                if (customersPresent[i] == Areas.bottomLeft)
                {
                    if (presentBottomLeft == 0)
                    {
                        bottomLeftCust = new customer(order.Order(), leftCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentBottomLeft = 1;

                    }
                }
                else if (customersPresent[i] == Areas.bottomRight)
                {
                    if (presentBottomRight == 0)
                    {
                        bottomRightCust = new customer(order.Order(), rightCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentBottomRight = 1;

                    }
                }
                else if (customersPresent[i] == Areas.left)
                {
                    if (presentLeft == 0)
                    {
                        leftCust = new customer(order.Order(), leftCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentLeft = 1;

                    }
                }
                else if (customersPresent[i] == Areas.right)
                {
                    if (presentRight == 0)
                    {
                        rightCust = new customer(order.Order(), rightCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentRight = 1;

                    }
                }
                else if (customersPresent[i] == Areas.topCenter)
                {
                    if (presentTopCenter == 0)
                    {
                        topCenterCust = new customer(order.Order(), rightCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentTopCenter = 1;

                    }
                }
                else if (customersPresent[i] == Areas.topLeft)
                {
                    if (presentTopLeft == 0)
                    {
                        topLeftCust = new customer(order.Order(), leftCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentTopLeft = 1;

                    }
                }
                else if (customersPresent[i] == Areas.topRight)
                {
                    if (presentTopRight == 0)
                    {
                        topRightCust = new customer(order.Order(), rightCharacters[randomNum.Next(0, leftCharacters.Count)]);
                        presentTopRight = 1;

                    }
                }


            }
        }



        //this compares the items a player has with the items a customer has depending on what the player
        //pressed and removes them if they match
        private void orderComparison(character player, customer current, GamePadState previousState, GamePadState padNow)
        {
            if (player.Carrying.Count() == 1 && (padNow.Buttons.LeftShoulder == ButtonState.Released
                    && previousState.Buttons.LeftShoulder == ButtonState.Pressed
                    || padNow.Triggers.Left < .5 && previousState.Triggers.Left > .5)
                    )
            {
                if (current.Order.Contains(player.Carrying[0]))
                {
                    current.Order.Remove(player.Carrying[0]);
                    player.Carrying.RemoveAt(0);
                    player.ItemsServed = player.ItemsServed + 1;
                    player.Score = player.Score + 5;
                    serveSound.Play();
                }
                else wrongItemSound.Play();
            }
            else if (player.Carrying.Count() == 2)
            {
                //while most button presses occur after the button is released the right shoulder button
                //is processes here when the button is pressed. This solves the problem of pressing both
                //shoulder buttons at the same time and the left item being used
                if (padNow.Buttons.RightShoulder == ButtonState.Pressed || padNow.Triggers.Right > .5)
                {
                    if (current.Order.Contains(player.Carrying[1]))
                    {
                        current.Order.Remove(player.Carrying[1]);
                        player.Carrying.RemoveAt(1);
                        player.ItemsServed = player.ItemsServed + 1;
                        player.Score = player.Score + 5;
                        serveSound.Play();
                    }
                    else wrongItemSound.Play();
                }
                if (padNow.Buttons.LeftShoulder == ButtonState.Released
                && previousState.Buttons.LeftShoulder == ButtonState.Pressed
                || padNow.Triggers.Left < .5 && previousState.Triggers.Left > .5)
                {
                    if (current.Order.Contains(player.Carrying[0]))
                    {
                        current.Order.Remove(player.Carrying[0]);
                        player.Carrying.RemoveAt(0);
                        player.ItemsServed = player.ItemsServed + 1;
                        player.Score = player.Score + 5;
                        serveSound.Play();
                    }
                    else wrongItemSound.Play();
                }
            }


        }


        //checks for the boundries which the player can not cross because static objects are in the way. 
        //This may or may not get a dynamic items sibling (other players)
        private void AreaCollision(character thisPlayer, int xPrevious, int yPrevious)
        {
            int offset = 7;
            //This is the candy table
            //the area is defined to be if the player has reached a position between the first and second 
            //test in y and the third an fourth test in x
            if (120 < thisPlayer.position.Y && thisPlayer.position.Y < 170 &&
    thisPlayer.position.X > 500 && thisPlayer.position.X < 710)
            {
                if (thisPlayer.position.Y < 120 + offset)
                    thisPlayer.position.Y = 120;
                else if (thisPlayer.position.X < 500 + offset)
                    thisPlayer.position.X = 500;
                else if (thisPlayer.position.Y > 170 - offset)
                    thisPlayer.position.Y = 170;
                else if (thisPlayer.position.X > 710 - offset)
                    thisPlayer.position.X = 710;
            }

            //this is the soda table
            else if (240 < thisPlayer.position.Y && thisPlayer.position.Y < 290 &&
    thisPlayer.position.X > 204 && thisPlayer.position.X < 411)
            {
                if (thisPlayer.position.Y < 240 + offset)
                    thisPlayer.position.Y = 240;
                else if (thisPlayer.position.X < 204 + offset)
                    thisPlayer.position.X = 204;
                else if (thisPlayer.position.Y > 290 - offset)
                    thisPlayer.position.Y = 290;
                else if (thisPlayer.position.X > 411 - offset)
                    thisPlayer.position.X = 411;
            }

            //this is the popcorn table
            else if (240 < thisPlayer.position.Y && thisPlayer.position.Y < 290 &&
                thisPlayer.position.X > 795 && thisPlayer.position.X < 1005)
            {
                if (thisPlayer.position.Y < 240 + offset)
                    thisPlayer.position.Y = 240;
                else if (thisPlayer.position.X < 795 + offset)
                    thisPlayer.position.X = 795;
                else if (thisPlayer.position.Y > 290 - offset)
                    thisPlayer.position.Y = 290;
                else if (thisPlayer.position.X > 1005 - offset)
                    thisPlayer.position.X = 1005;
            }

            //this is the nachos table
            else if (400 < thisPlayer.position.Y && thisPlayer.position.Y < 455 &&
                thisPlayer.position.X > 497 && thisPlayer.position.X < 707)
            {
                if (thisPlayer.position.Y < 400 + offset)
                    thisPlayer.position.Y = 400;
                else if (thisPlayer.position.X < 497 + offset)
                    thisPlayer.position.X = 497;
                else if (thisPlayer.position.Y > 455 - offset)
                    thisPlayer.position.Y = 455;
                else if (thisPlayer.position.X > 707 - offset)
                    thisPlayer.position.X = 707;
            }

            //this is the garbage can
            else if (250 < thisPlayer.position.Y && thisPlayer.position.Y < 290 &&
                thisPlayer.position.X > 540 && thisPlayer.position.X < 662)
            {
                if (thisPlayer.position.Y < 250 + offset)
                    thisPlayer.position.Y = 250;
                else if (thisPlayer.position.X < 540 + offset)
                    thisPlayer.position.X = 540;
                else if (thisPlayer.position.Y > 290 - offset)
                    thisPlayer.position.Y = 290;
                else if (thisPlayer.position.X > 662 - offset)
                    thisPlayer.position.X = 662;
            }


        //this is the left diagonal boundary checks
            else if (thisPlayer.position.X >= 134 && thisPlayer.position.X <= 250)
            {
                //this takes care of the top left diagonal
                if (thisPlayer.position.Y < 340)
                {
                    y1 = -thisPlayer.position.X * 148 / 116 + 368;

                    if (thisPlayer.position.Y < y1)
                    {
                        thisPlayer.position.X = xPrevious;
                        thisPlayer.position.Y = yPrevious;
                    }
                }

                //this test takes care of the bottom left diagonal
                //this was more involved because the top and bottom diagonals are not the same size
                else if (thisPlayer.position.X <= 180)
                {
                    y1 = thisPlayer.position.X * 84 / 85 + 316;
                    if (thisPlayer.position.Y > y1) thisPlayer.position.Y = y1;
                }
                else if (thisPlayer.position.Y > 500)
                    thisPlayer.position.Y = 500;
            }

                //this is the right diagonal boundary checks
            else if (thisPlayer.position.X >= 980 && thisPlayer.position.X <= 1080)
            {
                //this checks the top right boundary
                if (thisPlayer.position.Y < 340)
                {
                    y1 = thisPlayer.position.X * 150 / 120 - 1160;
                    if (thisPlayer.position.Y < y1) thisPlayer.position.Y = y1;
                }

                    //this takes care of the bottom right diagonal boundary
                else
                {
                    y1 = -thisPlayer.position.X * 60 / 100 + 1088;
                    if (thisPlayer.position.Y > y1) thisPlayer.position.Y = y1;

                }
            }

            //This is the top arena boundary
            else if (thisPlayer.position.Y < 50)
                thisPlayer.position.Y = 50;

            //this is the bottom arena boundary
            else if (thisPlayer.position.Y > 500) thisPlayer.position.Y = 500;

            //this is the left boundary
            else if (thisPlayer.position.X < 134)
            {
                thisPlayer.position.X = 134;

                //these two fix the glitch where the character seeed to slide upon reaching the 
                //diagonal boundaries
                if (thisPlayer.position.Y < 240) thisPlayer.position.Y = 240;
                if (thisPlayer.position.Y > 448) thisPlayer.position.Y = 448;
            }

                //this is the right boundary
            else if (thisPlayer.position.X > 1080)
            {
                thisPlayer.position.X = 1080;

                //these two fix the glitch where the character seeed to slide upon reaching the 
                //diagonal boundaries
                if (thisPlayer.position.Y < 190) thisPlayer.position.Y = 190;
                if (thisPlayer.position.Y > 440) thisPlayer.position.Y = 440;
            }


        }


        //checks if a player is inside an area (near a table or customer) and returns what area that is while 
        //making that area glow
        protected Areas AreaEnabled(character thisPlayer)
        {
            if (85 < thisPlayer.position.Y && thisPlayer.position.Y < 185 &&
   thisPlayer.position.X > 465 && thisPlayer.position.X < 740)
            {
                return Areas.candy;
            }

            else if (205 < thisPlayer.position.Y && thisPlayer.position.Y < 305 &&
    thisPlayer.position.X > 189 && thisPlayer.position.X < 446)
            {

                return Areas.soda;
            }

            else if (205 < thisPlayer.position.Y && thisPlayer.position.Y < 305 &&
                thisPlayer.position.X > 760 && thisPlayer.position.X < 1040)
            {

                return Areas.popcorn;
            }

            else if (365 < thisPlayer.position.Y && thisPlayer.position.Y < 470 &&
                thisPlayer.position.X > 462 && thisPlayer.position.X < 742)
            {

                return Areas.nachos;
            }

            else if (205 < thisPlayer.position.Y && thisPlayer.position.Y < 315 &&
                thisPlayer.position.X > 505 && thisPlayer.position.X < 697)
            {


                return Areas.garbage;
            }

                //customer areas
            else if (thisPlayer.position.Y < 90 && thisPlayer.position.X < 360)
            {
                return Areas.topLeft;
            }

            else if (thisPlayer.position.Y < 90 && thisPlayer.position.X > 380 && thisPlayer.position.X < 750)
            {
                return Areas.topCenter;
            }

            else if (thisPlayer.position.Y < 90 && thisPlayer.position.X > 830)
            {
                return Areas.topRight;
            }

            else if (thisPlayer.position.Y > 400 && thisPlayer.position.X < 225)
            {
                return Areas.bottomLeft;
            }

            else if (thisPlayer.position.Y > 400 && thisPlayer.position.X > 930)
            {
                return Areas.bottomRight;
            }

            else if (thisPlayer.position.Y < 350 && thisPlayer.position.Y > 100 && thisPlayer.position.X < 150)
            {
                return Areas.left;
            }
            else if (thisPlayer.position.Y < 350 && thisPlayer.position.Y > 150 && thisPlayer.position.X > 1060)
            {
                return Areas.right;
            }


            else
            {

                //bubbleTexture = bubblePlainTexture;
                return Areas.floor;
            }
        }


    }

    //this is the character class, containing the character's position and size in a rectangle as well as
    //the score and a list of items being carried. C# was not letting me make changes to the rectangle's
    //individual coordinates so ti make my life easier I made the rectangle public. Also notice how the
    //size of the list that carries items was left open 
    public class character
    {
        private int items;
        private int orders;
        private int saves;
        private int bonus;
        private int score;
        public Rectangle position;
        private List<item> carrying = new List<item>();

        public character(int itemsServed, int customersSaved, int ordersFinished, int bonusPoints, int charScore, Rectangle charPosition)
        {
            items = itemsServed;
            orders = ordersFinished;
            saves = customersSaved;
            bonus = bonusPoints;
            score = charScore;
            position = charPosition;
        }

        public int Score
        {
            get
            {
                return score;
            }
            set
            {
                score = value;
            }
        }

        public int CustomersSaved
        {
            get
            {
                return saves;
            }
            set
            {
                saves = value;
            }
        }

        public int BonusPoints
        {
            get
            {
                return bonus;
            }
            set
            {
                bonus = value;
            }
        }

        public int OrdersFinished
        {
            get
            {
                return orders;
            }
            set
            {
                orders = value;
            }
        }

        public int ItemsServed
        {
            get
            {
                return items;
            }
            set
            {
                items = value;
            }
        }

        public List<item> Carrying
        {
            get
            {
                return carrying;
            }
            set
            {
                carrying = value;
            }
        }
    }

    //this is the customer class which takes a list of items as an order, the customer's textures as well as
    //a patience and bonus amounts as well as a coloring. While everything can be modified there is only
    //one way to initialize a customer. The idea is that a customer is given textures and an order
    //and all other parameters are calculated from that order
    public class customer
    {
        private List<item> order;
        private int patience;
        private int bonus;
        private colorings claimed;
        public List<Texture2D> textures;
        private Texture2D currentTexture;

        public customer(List<item> newOrder, List<Texture2D> texturesCollection)
        {
            textures = texturesCollection;
            currentTexture = textures[0];
            patience = newOrder.Count() * 8;//5
            bonus = newOrder.Count() * 2;
            order = newOrder;
            claimed = colorings.white;
        }

        public Texture2D CurrentTexture
        {
            get
            {
                return currentTexture;
            }
            set
            {
                currentTexture = value;
            }
        }

        public List<item> Order
        {
            get
            {
                return order;
            }
            set
            {
                order = value;
            }
        }
        public int Patience
        {
            get
            {
                return patience;
            }
            set
            {
                patience = value;
            }
        }

        public colorings Claimed
        {
            get
            {
                return claimed;
            }
            set
            {
                claimed = value;
                if (claimed == colorings.white)
                    currentTexture = textures[0];
                else if (claimed == colorings.blue)
                    currentTexture = textures[1];
                else if (claimed == colorings.red)
                    currentTexture = textures[2];


            }
        }
        public int Bonus
        {
            get
            {
                return bonus;
            }
            set
            {
                bonus = value;
            }
        }

    }

    //this is the item class, containing the item name (from the item enum type) and a texture2d
    public class item
    {
        private Items itemName;
        private Texture2D itemTexture;

        public item(Items itemNam, Texture2D itemPic)
        {
            itemName = itemNam;
            itemTexture = itemPic;
        }

        public Items ItemName
        {
            get
            {
                return itemName;
            }
            set
            {
                itemName = value;
            }
        }
        public Texture2D ItemTexture
        {
            get
            {
                return itemTexture;
            }
            set
            {
                itemTexture = value;
            }
        }
    }


    //this class uses the item class and depending on th level and items available generates orders.
    //in retrospect, this could have probably just been a function. I simply found the sintax of 
    //something.order appealing
    public class orderMaker
    {
        private int level;
        private List<item> available;
        Random random = new Random();

        public orderMaker(int difficulty, List<item> foodKinds)
        {
            level = difficulty;
            available = foodKinds;
        }
        public int Level
        {
            get
            {
                return level;
            }
            set
            {
                level = value;
            }
        }
        public List<item> Available
        {
            get
            {
                return available;
            }
            set
            {
                available = value;
            }
        }

        //this function generates an order by using randomly generated numbers for the 
        //number of items in an order, picking an item from the item list and he number of that item to
        //be ordered and returns that list.
        public List<item> Order()
        {

            int items;
            int Ofeach;
            int itemNumber;
            List<int> used = new List<int>();
            List<item> finalList = new List<item>();

            if (level <= 4)
            {
                items = random.Next(1, level + 1);
                while (items != 0)
                {
                    random = new Random();
                    itemNumber = random.Next(0, available.Count);
                    if (used.Contains(itemNumber)) { }
                    else
                    {
                        used.Add(itemNumber);
                        Ofeach = random.Next(1, items);
                        items = items - Ofeach;
                        for (int i = 1; i <= Ofeach; i++)
                        {
                            finalList.Add(available[itemNumber]);
                        }
                    }
                }
                return finalList;
            }
            else
            {
                items = random.Next(2, 5);
                while (items != 0)
                {
                    itemNumber = random.Next(0, available.Count);
                    if (used.Contains(itemNumber)) { }
                    else
                    {
                        used.Add(itemNumber);
                        Ofeach = random.Next(1, items);
                        items = items - Ofeach;
                        for (int i = 1; i <= Ofeach; i++)
                        {
                            finalList.Add(available[itemNumber]);
                        }
                    }
                }
                return finalList;
            }

            /*this is the code for the previous order maker in case we ever decide to go back to 
             * bigger orders
             * if (level <= 4)
            {
                items = random.Next(1, level + 3);
                while (items != 0)
                {
                    itemNumber = random.Next(0, available.Count);
                    if (used.Contains(itemNumber)) ;
                    else
                    {
                        used.Add(itemNumber);
                        Ofeach = random.Next(1, items);
                        items = items - Ofeach;
                        for (int i = 1; i <= Ofeach; i++)
                        {
                            finalList.Add(available[itemNumber]);
                        }
                    }
                }
                return finalList;
            }

            else if (level >= 8)
            {
                items = random.Next(5, 11);
                while (items != 0)
                {
                    itemNumber = random.Next(0, available.Count);
                    if (used.Contains(itemNumber)) ;
                    else
                    {
                        used.Add(itemNumber);
                        Ofeach = random.Next(1, 4);
                        if (Ofeach > items) Ofeach = items;
                        items = items - Ofeach;
                        for (int i = 1; i <= Ofeach; i++)
                        {
                            finalList.Add(available[itemNumber]);
                        }
                    }
                }
                return finalList;
            }
            else
            {
                items = random.Next(level - 2, level + 3);
                while (items != 0)
                {
                    itemNumber = random.Next(0, available.Count);
                    if (used.Contains(itemNumber)) ;
                    else
                    {
                        used.Add(itemNumber);
                        Ofeach = random.Next(1, 5);
                        if (Ofeach > items) Ofeach = items;
                        items = items - Ofeach;
                        for (int i = 1; i <= Ofeach; i++)
                        {
                            finalList.Add(available[itemNumber]);
                        }
                    }
                }
                return finalList;
            }*/
        }
    }
}